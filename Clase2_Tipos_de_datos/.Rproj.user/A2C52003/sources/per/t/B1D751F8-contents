---
title: "Tipos de datos"
output: github_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

library(tidyverse)

```

Existen diversos tipos de variables, como las numericas, de texto, de fecha u ordinales.

Para analizarlos, lo primero que debemos hacer es cargar la data tabular, utilizando la funcion read.csv


```{r}

data <- read.csv("rankings_1973-2017.csv", header = TRUE, sep = ",")

head(data)

```

Vemos que en la tabla registros con datos faltantes, y otros con datos no validos (NA), vamos a validarlo con la funcion summary

```{r}
summary(data)

```

También nos interea explorar el numero de filas y de columnas de la tabla

```{r}

dim(data)
```

# Pre procesamiento de la data

El pre procesamiento de la data es un conjunto de pasos que debe ejecutarse con un uso especifico, no es un proceso general para la data. 

En este caso el uso espefico lo definiremos como estudiar la evolucion del top 5% jugadores del tenis ATP desde el año 2000.

## Reducción de dimensionalidad y selección de variables

Para simplificar el analisis consideraremos:

- Data desde el año 2000. 
- Variables week_year, rank_number, player_slug

```{r}
# en R base definimos el nuevo objeto data1 al especificar filas y columnas de la data original
# los corchetes cuadrados denotan [fila, columna]
data1 <- data[data$week_year >= 2000, c("week_year", "rank_number", "player_slug")]

dim(data1)

```

Mismo resultado puede obtenerse utilizando el dialecto de R llamado Tidyverse

```{r}

data2 <- data %>% 
            filter(week_year >= 2000) %>% 
            select(week_year, rank_number, player_slug)

dim(data2)

```

## Encontrar y tratar con entidades duplicadas 

Si queremos preservar solo las entindades únicas podemos utilizar la funcion unique()

```{r}
unicos <- unique(data2)

dim(unicos)

```

## Muestreo

Para hacer un muestreo simple sin reemplazo podemos usar la funcion sample()

```{r}

sampleIndex <- sample(nrow(unicos),1000, replace = F)

sampleData <- unicos[sampleIndex,]

```
## Agregación

Si quisiera agregar la el ranking para cada año-jugador, mejor usamos directamente la funcion aggregate

```{r}

agg_df <- aggregate(rank_number ~ week_year + player_slug, data1, median)

dim(agg_df)

```


## Normalización / Estandarización

Ya tenemos el ranking mediano, pero queremos saber la posición relativa que ese ranking corresponde en cada año. Para esto debemos dividir el ranking de cada año, por el maximo valor de ese año. 

Con esto la variable resultante fluctuará entre 0 y 1. 

```{r}
# calculamos el maximo valor anual con aggregate
max_rank <- aggregate(rank_number ~ week_year, agg_df, max)

colnames(max_rank)[2] <- "max"

agg_df <- merge(agg_df, max_rank, by="week_year")


agg_df$rank_relative <- agg_df$rank_number / agg_df$max

summary(agg_df)
```


## Discretización 

Crearemos una variable discreta que valdrá 1 en caso que el ranking relativo este en el 5% superior, 0 en caso contrario

```{r}

agg_df$top5perc <- as.numeric(agg_df$rank_relative <= 0.05)
agg_df$top10 <- as.numeric(agg_df$rank_number <= 10)

plot(agg_df$top5, log(agg_df$rank_number))

```

Finalmente puedo analizar solamente al top 5% con un grafico de evolucion
```{r}
library(ggplot2)

data_plot <- agg_df %>% filter(top10 == 1) 

ggplot(data_plot) + 
  geom_line(aes(week_year,rank_number, col =player_slug )) + 
  theme(legend.position = "bottom") +
  scale_y_reverse()

```



