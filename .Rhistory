##########################################
#############Grubbs Test##################
##########################################
#install.packages("outliers")
library(outliers)
dataOutlier=grubbs.test(data$IngresoPerCapita, two.sided=F)
dataOutlier
##########################################
#############Mahalanobis##################
##########################################
library(ggplot2)
distM=mahalanobis(data[,c(4,5)],colMeans(data[,c(4,5)]),cov(data[,c(4,5)]))
? mahalanobis
#Displaying the countries
subDataCercanos=data[indexM[1:5],]
subDataLejanos=data[distM>10,]
#Sorting the distances
indexM=sort(distM, index.return=TRUE)$ix
ggplot()+
aes(x=distM)+
theme_bw()+
geom_density()+
theme(text=element_text(size=25))
#Displaying the countries
subDataCercanos=data[indexM[1:5],]
subDataLejanos=data[distM>10,]
ggplot(data)+
#aes(x=TasaFertilidad,y=IngresoPerCapita) +   theme_bw()+
aes(x=TasaFertilidad,y=IngresoPerCapita,color=distM) +   theme_bw()+
scale_color_gradient(low="blue",high="red")+
geom_point(size=1,alpha=0.8)+theme_bw()+
theme(text=element_text(size=25))+
ggtitle("Tasa Fertilidad vs Ingreso Per Cápita (2019)") + theme(plot.title = element_text(size = 20, face="bold", hjust=0.5))+
xlab("Promedio de niños por mujer") + ylab("Promedio ingreso per capita, en miles de US$") + theme(axis.title = element_text(size = 12),axis.text = element_text(size = 10, color="black"))
##########################################
#####Outlier based on KNN distance########
##########################################
#install.packages("distances")
#install.packages("dbscan")
library(distances)
library(dbscan)
#Calculating the matrix using the mahalanobis distance
indexCol=c(4,5)
tempDist=distances(data[indexCol],normalize = "mahalanobize")
tempDist=as.dist(tempDist)
#extracting the indexes with highest distance to the 4th neighboor
temp=kNNdist(tempDist,10,all=T)
temp=temp[,10]
ggplot()+
aes(x=temp)+
theme_bw()+
geom_density()+
theme(text=element_text(size=25))
#Displaying the countries
subData=data[temp>7.5,]
ggplot(data)+
#aes(x=TasaFertilidad,y=IngresoPerCapita) +   theme_bw()+
aes(x=TasaFertilidad,y=IngresoPerCapita,color=temp) +   theme_bw()+
scale_color_gradient(low="blue",high="red")+
geom_point(size=1,alpha=0.8)+theme_bw()+
ggtitle("Tasa Fertilidad vs Ingreso Per Cápita (2019)") + theme(plot.title = element_text(size = 20, face="bold", hjust=0.5))+
xlab("Promedio de niños por mujer") + ylab("Promedio ingreso per capita, en miles de US$") + theme(axis.title = element_text(size = 15),axis.text = element_text(size = 10, color="black"))
indexCol=c(4,5)
tempDist=distances(data[indexCol],normalize = "mahalanobize")
tempDist=as.dist(tempDist)
outlierScores = dbscan::lof(tempDist, k=5)
ggplot(aes(x=outlierScores)) +
geom_density() +
theme_bw() +
theme(text=element_text(size=18))
indexCol=c(4,5)
tempDist=distances(data[indexCol],normalize = "mahalanobize")
tempDist=as.dist(tempDist)
outlierScores = dbscan::lof(tempDist, k=5)
ggplot(aes(x=outlierScores)) +
geom_density() +
theme_bw() +
theme(text=element_text(size=18))
ggplot(outlierScores, aes(x = outlierScores)) +
geom_density() +
theme_bw() +
theme(text=element_text(size=18))
ggplot()+aes(x=outlierScores)+theme_bw()+geom_density()+theme(text=element_text(size=18))
#Displaying the countries
subData=data[outlierScores>3,]
ggplot(data)+
#aes(x=TasaFertilidad,y=IngresoPerCapita) +   theme_bw()+
aes(x=TasaFertilidad,y=IngresoPerCapita,color=outlierScores) +   theme_bw()+
scale_color_gradient(low="blue",high="red")+
geom_point(size=1,alpha=0.8)+theme_bw()+
ggtitle("Tasa Fertilidad vs Ingreso Per Cápita (2019)") + theme(plot.title = element_text(size = 20, face="bold", hjust=0.5))+
xlab("Promedio de niños por mujer") + ylab("Promedio ingreso per capita, en miles de US$") + theme(axis.title = element_text(size = 15),axis.text = element_text(size = 10, color="black"))+
geom_text(data=subData,label=subData$Abrev,color="blue")
ggplot(data, aes(x = TasaFertilidad, y = IngresoPerCapita, color=outlierScores)) +
geom_point(size=1,alpha=0.8) +
theme_bw() +
scale_color_gradient(low="blue", high="red")+
ggtitle("Tasa Fertilidad vs Ingreso Per Cápita (2019)") + theme(plot.title = element_text(size = 20, face="bold", hjust=0.5))+
xlab("Promedio de niños por mujer") + ylab("Promedio ingreso per capita, en miles de US$") + theme(axis.title = element_text(size = 15),axis.text = element_text(size = 10, color="black"))+
geom_text(data=subData,label=subData$Abrev,color="blue")
Para analizar casos atipicos, vamos a utilziar un dataset con las tasas de fertilidad
knitr::opts_chunk$set(echo = TRUE)
```{r cars}
library(ggplot2)
data <-read.csv("./tasaFertilidad2019vsGPD.csv")
# cargo datos
data <- read.csv("tasaFertilidad2019vsGPD.csv")
data %>% glimpse()
library(tidyverse)
```{r setup, include=FALSE, message = FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(tidyverse)
# cargo datos
data <- read.csv("tasaFertilidad2019vsGPD.csv")
data %>% glimpse()
# genero grafico
ggplot(data)+
aes(x = TasaFertilidad, y = IngresoPerCapita) +
geom_point() + # esto genera un grafico de dispersion de TasaFertilidad vs IngresoPerCapita
ggtitle("Tasa Fertilidad vs Ingreso Per Cápita (2019)") +
xlab("Promedio de niños por mujer") +
ylab("Promedio ingreso per capita, en miles de US$") +
theme_bw() +
theme(axis.title = element_text(size = 15),
axis.text = element_text(size = 10, color="black"),
plot.title = element_text(size = 20, face="bold", hjust=0.5),
text = element_text(size=25))
library(outliers)
# calculo el test de grub sobre la variable IngresoPerCapita
dataOutlier = grubbs.test(data$IngresoPerCapita, two.sided=F)
dataOutlier
# calculo el test de grub sobre la variable TasaFertilidad
dataOutlier = grubbs.test(data$TasaFertilidad, two.sided=F)
dataOutlier
predict(dataOutlier)
dataOutlier$data.name
dataOutlier$statistic
? grubbs.test
# calculo el test de grub sobre la variable TasaFertilidad
dataOutlier2 = grubbs.test(data$TasaFertilidad, two.sided=F, type = 20)
# calculo el test de grub sobre la variable TasaFertilidad
dataOutlier2 = grubbs.test(data$TasaFertilidad, two.sided=F, type = 20)
# calculo el test de grub sobre la variable TasaFertilidad
dataOutlier2 = grubbs.test(data$TasaFertilidad, type = 20)
# calculo el test de grub sobre la variable TasaFertilidad
dataOutlier2 = grubbs.test(data$TasaFertilidad, two.sided=F, type = 2)
# calculo el test de grub sobre la variable TasaFertilidad
dataOutlier2 = grubbs.test(data$TasaFertilidad, two.sided=F)
distM = mahalanobis(data[,c(4,5)],colMeans(data[,c(4,5)]),cov(data[,c(4,5)]))
sort(distM, index.return=TRUE)$ix
ggplot(data)+
aes(x=TasaFertilidad,y=IngresoPerCapita,color=distM) +
scale_color_gradient(low="blue",high="red")+
geom_point(size=1,alpha=0.8)+theme_bw()+
ggtitle("Tasa Fertilidad vs Ingreso Per Cápita (2019)") +
xlab("Promedio de niños por mujer") +
ylab("Promedio ingreso per capita, en miles de US$") +
theme_bw() +
theme(axis.title = element_text(size = 12),
axis.text = element_text(size = 10, color="black"),
text=element_text(size=25),
plot.title = element_text(size = 20, face="bold", hjust=0.5))
ggplot()+
aes(x=distM)+
theme_bw()+
geom_density()+
theme(text=element_text(size=25))
ggplot(data, aes(x=TasaFertilidad, y=IngresoPerCapita,color=distM)) +
scale_color_gradient(low="blue",high="red")+
geom_point(size=1,alpha=0.8)+theme_bw()+
ggtitle("Tasa Fertilidad vs Ingreso Per Cápita (2019)") +
xlab("Promedio de niños por mujer") +
ylab("Promedio ingreso per capita, en miles de US$") +
theme_bw() +
theme(axis.title = element_text(size = 12),
axis.text = element_text(size = 10, color="black"),
text=element_text(size=25),
plot.title = element_text(size = 20, face="bold", hjust=0.5))
# Visualizo la distribucion de las distancias
ggplot(distM %>% as.tibble())+
aes(x=distM)+
theme_bw()+
geom_density()+
theme(text=element_text(size=25))
# Visualizo la distribucion de las distancias
ggplot(distM %>% as_tibble())+
aes(x=distM)+
theme_bw()+
geom_density()+
theme(text=element_text(size=25))
# Visualizo la distribucion de las distancias
ggplot(distM %>% as_tibble(), aes(x=distM))+
theme_bw()+
geom_density()+
theme(text=element_text(size=25))
# Visualizo la distribucion de las distancias
ggplot(distM %>% as_tibble())+
theme_bw()+
geom_density()+
theme(text=element_text(size=25))
# Visualizo la distribucion de las distancias
ggplot(distM %>% as_tibble(), aes(x=distM)) +
geom_density() +
theme_bw() +
theme(text=element_text(size=25))
ggplot(data, aes(x=TasaFertilidad, y=IngresoPerCapita,color=distM)) +
scale_color_gradient(low="blue",high="red") +
geom_point(size=1, alpha=0.8) +
ggtitle("Tasa Fertilidad vs Ingreso Per Cápita (2019)") +
xlab("Promedio de niños por mujer") +
ylab("Promedio ingreso per capita, en miles de US$") +
theme_bw() +
theme(axis.title = element_text(size = 12),
axis.text = element_text(size = 10, color="black"),
text=element_text(size=25),
plot.title = element_text(size = 20, face="bold", hjust=0.5))
# invoco librerias
library(distances)
library(dbscan)
#Calculating the matrix using the mahalanobis distance
indexCol=
tempDist=distances(data[,c(4,5)],normalize = "mahalanobize")
#Calculo distancias de mahalanobis, utilizando otro metodo disponible en la libreria distances
tempDist <- distances(data[,c(4,5)],normalize = "mahalanobize")
tempDist <- as.dist(tempDist)
#Calculo distancias de mahalanobis, utilizando otro metodo disponible en la libreria distances
tempDist <- distances(data[,c(4,5)],normalize = "mahalanobize") %>% as.dist()
#extracting the indexes with highest distance to the 4th neighboor
temp=kNNdist(tempDist,4,all=T)
temp=temp[,4]
#extracting the indexes with highest distance to the 4th neighboor
temp=kNNdist(tempDist,4,all=T)
temp=temp[,4]
ggplot()+
aes(x=temp)+
theme_bw()+
geom_density()+
theme(text=element_text(size=25))
ggplot(data, aes(x=TasaFertilidad,y=IngresoPerCapita,color=temp)) +
geom_point(size=1,alpha=0.8)+theme_bw()+
scale_color_gradient(low="blue",high="red")+
ggtitle("Tasa Fertilidad vs Ingreso Per Cápita (2019)") +
theme_bw() +
theme(plot.title = element_text(size = 20, face="bold", hjust=0.5),
axis.title = element_text(size = 15),
axis.text = element_text(size = 10, color="black")) +
xlab("Promedio de niños por mujer") +
ylab("Promedio ingreso per capita, en miles de US$")
ggplot(temp %>% as_tibble(), aes(x=temp)) +
geom_density() +
theme_bw() +
theme(text=element_text(size=25))
# visualizo la densidad de estas distancias
ggplot(temp %>% as_tibble(), aes(x=temp)) +
geom_density() +
theme_bw() +
theme(text=element_text(size=25))
#preservo las 4 distancias menores
temp <- kNNdist(tempDist, 4, all=T)
temp[1,]
# visualizo el diagrama de dispersion, coloreado segun distancia maxima de knn
ggplot(data, aes(x=TasaFertilidad,y=IngresoPerCapita,color=temp)) +
geom_point(size=1,alpha=0.8)+theme_bw()+
scale_color_gradient(low="blue",high="red")+
ggtitle("Tasa Fertilidad vs Ingreso Per Cápita (2019)") +
theme_bw() +
theme(plot.title = element_text(size = 20, face="bold", hjust=0.5),
axis.title = element_text(size = 15),
axis.text = element_text(size = 10, color="black")) +
xlab("Promedio de niños por mujer") +
ylab("Promedio ingreso per capita, en miles de US$")
temp <- temp[,4] # preservo la maxima de las 4 distancias cercanas
# visualizo la densidad de estas distancias maximas
ggplot(temp %>% as_tibble(), aes(x=temp)) +
geom_density() +
theme_bw() +
theme(text=element_text(size=25))
# visualizo el diagrama de dispersion, coloreado segun distancia maxima de knn
ggplot(data, aes(x=TasaFertilidad,y=IngresoPerCapita,color=temp)) +
geom_point(size=1,alpha=0.8)+theme_bw()+
scale_color_gradient(low="blue",high="red")+
ggtitle("Tasa Fertilidad vs Ingreso Per Cápita (2019)") +
theme_bw() +
theme(plot.title = element_text(size = 20, face="bold", hjust=0.5),
axis.title = element_text(size = 15),
axis.text = element_text(size = 10, color="black")) +
xlab("Promedio de niños por mujer") +
ylab("Promedio ingreso per capita, en miles de US$")
# genero grafico
ggplot(data, aes(x = TasaFertilidad, y = IngresoPerCapita)) +
geom_point() + # esto genera un grafico de dispersion de TasaFertilidad vs IngresoPerCapita
ggtitle("Tasa Fertilidad vs Ingreso Per Cápita (2019)") +
xlab("Promedio de niños por mujer") +
ylab("Promedio ingreso per capita, en miles de US$") +
theme_bw() +
theme(axis.title = element_text(size = 15),
axis.text = element_text(size = 10, color="black"),
plot.title = element_text(size = 20, face="bold", hjust=0.5),
text = element_text(size=25))
outlierScores = dbscan::lof(tempDist, k=5)
## calculo el lof a partir de distancias mahalanobis calculadas en paso anterior (tempDist)
outlierScores = dbscan::lof(tempDist, k=5)
ggplot(outlierScores %>% as_tibble(), aes(x= outlierScores)) +
theme_bw() +
geom_density() +
theme(text=element_text(size=18))
ggplot(outlierScores %>% as_tibble(), aes(x= outlierScores)) +
geom_density() +
theme_bw() +
theme(text=element_text(size=18))
# genero subconjunto de datos con puntajes de outliers altos
subData=data[outlierScores>3,]
ggplot(data, aes(x = TasaFertilidad, y = IngresoPerCapita, color = outlierScores)) +
geom_point(size=1,alpha=0.8) +
geom_text(data=subData,label=subData$Abrev,color="blue") +
scale_color_gradient(low="blue", high="red")+
ggtitle("Tasa Fertilidad vs Ingreso Per Cápita (2019)") +
xlab("Promedio de niños por mujer") +
ylab("Promedio ingreso per capita, en miles de US$") +
theme_bw() +
theme(axis.title = element_text(size = 15),
axis.text = element_text(size = 10, color="black"),
plot.title = element_text(size = 20, face="bold", hjust=0.5))
# visualizo dispersion, coloreada segun LOF
ggplot(data, aes(x = TasaFertilidad, y = IngresoPerCapita, color = outlierScores)) +
geom_point(size=1,alpha=0.8) +
geom_text(data=subData, label=subData$Abrev, color="blue") +  # visualizo los textos (Abrev) de valores atipicos
scale_color_gradient(low="blue", high="red")+
ggtitle("Tasa Fertilidad vs Ingreso Per Cápita (2019)") +
xlab("Promedio de niños por mujer") +
ylab("Promedio ingreso per capita, en miles de US$") +
theme_bw() +
theme(axis.title = element_text(size = 15),
axis.text = element_text(size = 10, color="black"),
plot.title = element_text(size = 20, face="bold", hjust=0.5))
data=read.csv("video_games_sales.csv")
getwd()
knitr::opts_chunk$set(echo = TRUE)
data  <- read.csv("video_games_sales.csv")
summary(data)
knitr::opts_chunk$set(echo = TRUE)
library(tidyverse)
library(tidyverse)
data  <- read.csv("video_games_sales.csv")
summary(data)
data$User_Score <- as.numeric(data$User_Score)
data <- data %>% filter(!(is.na(Critic_Score) | is.na(User_Score))) %>% select(-Global_Sales)
data_numerica <- data[,c(6:9, 10, 12)]
data_escala = scale(data_numerica) %>% as_tibble()
modelo_kmeans <- kmeans(data_escala, centers = 10)
# creo la variable cluster en la tabla data_escalada
data_escala$clus <- modelo_kmeans$cluster %>% as.factor()
ggplot(data_escala, aes(Critic_Score, User_Score, color=clus)) +
geom_point(alpha=0.5, show.legend = F) +
theme_bw()
SSinterior <- numeric(50)
for(k in 1:50){
modelo <- kmeans(data_escala, centers = k)
SSinterior[k] <- modelo$tot.withinss
}
for(k in 1:50){
modelo <- kmeans(data_escala, centers = k)
SSinterior[k] <- modelo$tot.withinss
}
plot(SSinterior)
# uso distancia euclidiana
tempDist <- dist(data_numerica) %>% as.matrix()
# uso distancia euclidiana
tempDist <- dist(data_numerica) %>% as.matrix()
#reordeno filas y columnas en base al cluster obtenido
index <- sort(modelo_kmeans$cluster, index.return=TRUE)
tempDist <- tempDist[index$ix,index$ix]
rownames(tempDist) <- c(1:nrow(data))
colnames(tempDist) <- c(1:nrow(data))
image(tempDist)
#Calcula el hopkins statistic
res <- get_clust_tendency(data_numerica, n = 30, graph = FALSE)
library(factoextra)
#Calcula el hopkins statistic
res <- get_clust_tendency(data_numerica, n = 30, graph = FALSE)
#Calcula el hopkins statistic
res <- get_clust_tendency(data_numerica, n = 30, graph = FALSE)
print(res)
#Correlation
#construyo matriz de correlacion ideal (cada entidad correlaciona 1 con su cluster)
tempMatrix <- matrix(0, nrow = nrow(data_escala), ncol = nrow(data_escala))
tempMatrix[which(index$x==1), which(index$x==1)]  <- 1
tempMatrix[which(index$x==2), which(index$x==2)]  <- 1
tempMatrix[which(index$x==3), which(index$x==3)]  <- 1
tempMatrix[which(index$x==3), which(index$x==4)]  <- 1
tempMatrix[which(index$x==3), which(index$x==5)]  <- 1
tempMatrix[which(index$x==3), which(index$x==6)]  <- 1
tempMatrix[which(index$x==3), which(index$x==7)]  <- 1
tempMatrix[which(index$x==3), which(index$x==8)]  <- 1
tempMatrix[which(index$x==3), which(index$x==9)]  <- 1
tempMatrix[which(index$x==3), which(index$x==10)] <- 1
#construyo matriz de disimilitud
tempDist2 <- 1/(1+tempDist)
#Calcula correlacion
cor <- cor(tempMatrix[upper.tri(tempMatrix)],tempDist2[upper.tri(tempDist2)])
print(cor)
withinCluster <- numeric(10)
for (i in 1:10){
tempData <- data_escala[which(modelo_kmeans$cluster == i),]
withinCluster[i] <- sum(dist2(tempData,colMeans(tempData))^2)
}
#Cohesion
#install.packages("flexclust")
library(flexclust) # usaremos la distancia
? dist2
withinCluster[i] <- sum(dist(tempData,colMeans(tempData))^2)
View(tempData)
dist(tempData,colMeans(tempData))
colMeans(tempData)
View(tempData)
tempData
#Cohesion
withinCluster <- numeric(10)
for (i in 1:10){
tempData <- data_escala[which(modelo_kmeans$cluster == i),]
withinCluster[i] <- sum(dist2(tempData,colMeans(tempData))^2)
}
#Cohesion
withinCluster <- numeric(10)
for (i in 1:10){
tempData <- data_escala[which(modelo_kmeans$cluster == i),]
withinCluster[i] <- sum(dist2(tempData,colMeans(tempData))^2)
}
colMeans(tempData)
is.numeric(tempData)
View(tempData)
apply(data_escala,2,is.numeric)
apply(data_escala,2,as.numeric)
data_escala <- apply(data_escala,2,as.numeric)
data_escala <- apply(data_escala,2,as.numeric)
#Cohesion
withinCluster <- numeric(10)
for (i in 1:10){
tempData <- data_escala[which(modelo_kmeans$cluster == i),]
withinCluster[i] <- sum(dist(tempData,colMeans(tempData))^2)
}
#Cohesion
withinCluster <- numeric(10)
for (i in 1:10){
tempData <- data_escala[which(modelo_kmeans$cluster == i),]
withinCluster[i] <- sum(dist2(tempData,colMeans(tempData))^2)
}
cohesion = sum(withinCluster)
#es equivalente a model$tot.withinss en k-means
print(cohesion)
#Separation
meanData <- colMeans(data_escala)
SSB <- numeric(10)
for (i in 1:10){
tempData <- data_escala[which(modelo_kmeans$cluster==i),]
SSB[i] <- nrow(tempData)*sum((meanData-colMeans(tempData))^2)
}
separation = sum(SSB)
#es equivalente a model$tot.betweeness en k-means
print(separacion)
#es equivalente a model$tot.betweeness en k-means
print(separation)
#es equivalente a model$tot.withinss en k-means
print(c,(cohesion, modelo_kmeans$tot.withinss))
#es equivalente a model$tot.withinss en k-means
print(c(cohesion, modelo_kmeans$tot.withinss))
#es equivalente a model$tot.betweeness en k-means
print(c(cohesion, modelo_kmeans$betweenss))
#es equivalente a model$tot.betweeness en k-means
print(c(separation, modelo_kmeans$betweenss))
#Separation
meanData <- colMeans(data_escala)
SSB <- numeric(10)
for (i in 1:10){
tempData <- data_escala[which(modelo_kmeans$cluster==i),]
SSB[i] <- nrow(tempData)*sum((meanData-colMeans(tempData))^2)
}
separation = sum(SSB)
#es equivalente a model$tot.betweeness en k-means
print(c(separation, modelo_kmeans$betweenss))
#es equivalente a model$tot.betweeness en k-means
print(c(separation, modelo_kmeans$totss))
#es equivalente a model$tot.betweeness en k-means
print(c(separation, modelo_kmeans$totss+ modelo_kmeans$betweenss))
print(separation)
#Silohouette coefficient
library(cluster)
coefSil <- silhouette(modelo_kmeans$cluster,dist(data_escala))
summary(coefSil)
#This is a ggplot package, so we can adjust some values
fviz_silhouette(coefSil) + coord_flip()
#Utilizamos el coeficiente de silueta para encontrar el mejor valor de K
coefSil=numeric(30)
for (k in 2:30){
modelo <- kmeans(data_escala, centers = k)
temp <- silhouette(modelo$cluster,dist(data_escala))
coefSil[k] <- mean(temp[,3])
}
for (k in 2:30){
modelo <- kmeans(data_escala, centers = k)
temp <- silhouette(modelo$cluster,dist(data_escala))
coefSil[k] <- mean(temp[,3])
}
for (k in 2:30){
modelo <- kmeans(data_escala, centers = k)
temp <- silhouette(modelo$cluster,dist(data_escala))
coefSil[k] <- mean(temp[,3])
}
tempDF=data.frame(CS=coefSil,K=c(1:30))
ggplot(tempDF, aes(x=K, y=CS)) +
geom_line() +
scale_x_continuous(breaks=c(1:30))
