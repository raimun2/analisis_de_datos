install.packages("M3C")
library(M3C)
library(Rtsne)
install.packages("Rtsne")
library(Rtsne)
tsne <- Rtsne(iris, dims = 2, perplexity=30, verbose=TRUE, max_iter = 500)
data(iris)
data(iris) %>% unique()
library(tidyverse)
data(iris) %>% unique()
iris <- iris %>% unique()
iris_num <- iris
iris_num$Species <- NULL
tsne <- Rtsne(iris_num, dims = 2, perplexity=30, verbose=TRUE, max_iter = 500)
tsne$Y
predict(PCA)
predict(PCA) %>% ggplot(aes(PC1,PC2)) + geom_point()
predict(PCA) %>% as.data.frame() %>%  ggplot(aes(PC1,PC2)) + geom_point()
predict(PCA) %>% as.data.frame() %>%  ggplot(aes(PC1,PC2, col=iris$Species)) + geom_point()
iris <<- iris %>% unique()
iris_unicos <- iris %>% unique()
predict(PCA) %>% as.data.frame() %>%  ggplot(aes(PC1,PC2, col=iris0$Species)) + geom_point()
data(iris)
iris0 <- iris %>% unique()
iris0 <- iris %>% unique()
iris0 <- iris %>% unique()
str(iris0)
# debemos transformar variable Species en numerica, lo hacemos creando variables dummy
iris0$setosa <- ifelse(iris0$Species == "setosa", 1, 0)
iris0$virginica <- ifelse(iris0$Species == "virginica", 1, 0)
iris0$versicolor <- ifelse(iris0$Species == "versicolor", 1, 0)
iris_num <- iris0 # creamos una copia de la data pero con varibles numericas solamente
iris_num$Species <- NULL
## primero probaremos el algoritmo de fuerza bruta
library(stuart)
results <- bruteforce(iris_num, list(ra = names(iris_num)), 3,
cores = 4)  # numero de nucleos en la maquina
summary(results)
## para el resto de los metodos utilizamos la siguiente libreria
library(FSinR)   # feature selection
# Para usarla, primero debemos utilizar un metodo de optimizacion, donde todas las opciones disponibles estan en
? searchAlgorithm
# Estos algoritmos buscaran el optimo en todo el espacio de soluciones
searcher <- searchAlgorithm('geneticAlgorithm')
searcher <- searchAlgorithm('tabu', list(tamTabuList = 4, iter = 5, intensification=2, iterIntensification=5, diversification=1, iterDiversification=5, verbose=FALSE) )
searcher <- searchAlgorithm('antColony')
searcher <- searchAlgorithm('sequentialForwardSelection')
## Luego tenemos que definir una variable para filtrar, las variables disponibles estan en
? filterEvaluator
filtro <- filterEvaluator("IEConsistency")
filtro <- filterEvaluator('determinationCoefficient')
filtro <- filterEvaluator('chiSquared')
filtro <- filterEvaluator('MDLC')
## finalmente optimizamos los atributos, utilizando la variable Species como referencia para pronosticar
results <- featureSelection(iris0, 'Species', searcher, filtro)
results$bestFeatures
## tambien se puede pronosticar la variable de referencia utilizando una funcion de envoltorio o wrapper. las funciones disponibles se pueden ver en
? wrapperEvaluator
evaluator <- wrapperEvaluator("knn")
evaluator <- wrapperEvaluator("xgbLinear")
evaluator <- wrapperEvaluator("lm")
evaluator <- wrapperEvaluator("svmLinearWeights")
evaluator <- wrapperEvaluator("mlpWeightDecay")
results <- featureSelection(iris0, 'Species', searcher, evaluator)
evaluator <- wrapperEvaluator("lm")
? searchAlgorithm
searcher <- searchAlgorithm('hillClimbing')
## finalmente optimizamos los atributos, utilizando la variable Species como referencia para pronosticar
results <- featureSelection(iris0, 'Species', searcher, filtro)
results$bestFeatures
## tambien se puede pronosticar la variable de referencia utilizando una funcion de envoltorio o wrapper. las funciones disponibles se pueden ver en
? wrapperEvaluator
evaluator <- wrapperEvaluator("knn")
evaluator <- wrapperEvaluator("xgbLinear")
evaluator <- wrapperEvaluator("svmLinearWeights")
evaluator <- wrapperEvaluator("mlpWeightDecay")
evaluator <- wrapperEvaluator("lm")
results <- featureSelection(iris0, 'Species', searcher, evaluator)
evaluator <- wrapperEvaluator("svmLinearWeights")
results <- featureSelection(iris0, 'Species', searcher, evaluator)
evaluator <- wrapperEvaluator("knn")
results <- featureSelection(iris0, 'Species', searcher, evaluator)
results$bestFeatures
directSearcher <- directSearchAlgorithm('selectKBest', list(k=3))
## ojo que la funcion es diferente a la anterior
results <- directFeatureSelection(iris0, 'Species', directSearcher, evaluator)
results$bestFeatures
#PCA
PCA <- prcomp(iris_num)
barplot(PCA$sdev)
predict(PCA) %>% as.data.frame() %>%  ggplot(aes(PC1,PC2, col=iris0$Species)) + geom_point()
library(GGally)
ggpairs(iris_num)
ggpairs(iris_num, aes(col=iris0$Species))
d <- dist(iris_num) # distancias euclidianas entre entidades
MDS <- cmdscale(d,eig=TRUE, k=2) # k es el numero de dimensiones de salida
MDS$points
MDS$points %>%  ggplot(aes( col=iris0$Species)) + geom_point()
MDS$points %>% as.data.frame()
MDS$points %>% as.data.frame() %>% colnames()
MDS$points %>% as.data.frame() %>% ggplot(aes(V1,V2, col=iris0$Species)) + geom_point()
nMDS$points %>% as.data.frame() %>% ggplot(aes(V1,V2, col=iris0$Species)) + geom_point()
library(MASS)
nMDS <- isoMDS(d, k=2)
nMDS$points %>% as.data.frame() %>% ggplot(aes(V1,V2, col=iris0$Species)) + geom_point()
library(Rtsne)
tsne <- Rtsne(iris_num, dims = 2, perplexity=30, verbose=TRUE, max_iter = 500)
tsne$Y
tsne$Y %>% as.data.frame() %>% ggplot(aes(V1,V2, col=iris0$Species)) + geom_point()
photo <- readJPEG("Imagen1.jpg")
library(jpeg)
photo <- readJPEG("Imagen1.jpg")
plot(photo)
knitr::opts_chunk$set(echo = TRUE, message = FALSE, warning = FALSE)
library(tidyverse)
tsne <- Rtsne(iris_num, dims = 2, perplexity=30, verbose=TRUE, max_iter = 500)
library(Rtsne)
Rtsne
? Rtsne
library(stuart)
? bruteforce
iris
data(iris)
force(iris)
rankingsATP <- read.csv("C:/Users/raimu/Dropbox/01.Docencia/2021.1.analisis_de_datos/analisis_de_datos/Clase2_Tipos_de_datos/rankingsATP.csv")
View(rankingsATP)
as.character(rankingsATP$rank_number)
as.character(rankingsATP$week_title)
strsplit(rankingsATP$week_title, ".")
strsplit(rankingsATP$week_title[1:10], ".")
rankingsATP$week_title
strsplit(rankingsATP$week_title[1:10], "\\.")
# expresiones regulares
fechas <- strsplit(rankingsATP$week_title[1:10], "\\.")
# expresiones regulares
fechas <- strsplit(rankingsATP$week_title[1:10], "\\.") %>% as.data.frame()
library(tidyverse)
# expresiones regulares
fechas <- strsplit(rankingsATP$week_title[1:10], "\\.") %>% as.data.frame()
View(fechas)
library(FSinR)
? searchAlgorithm
? filterEvaluator
? wrapperEvaluator
install.packages("lavaan")
library(readxl)
ALVARO_2 <- read_excel("C:/Users/raimu/Dropbox/07.Descargas/ALVARO 2.xls")
View(ALVARO_2)
knitr::opts_chunk$set(echo = TRUE)
data <-read.csv("./tasaFertilidad2019vsGPD.csv")
#Analyzing the outliers
ggplot(data)+
aes(x = TasaFertilidad, y = IngresoPerCapita) +
geom_point() +
ggtitle("Tasa Fertilidad vs Ingreso Per Cápita (2019)") +
xlab("Promedio de niños por mujer") +
ylab("Promedio ingreso per capita, en miles de US$") +
theme_bw() +
theme(axis.title = element_text(size = 15),
axis.text = element_text(size = 10, color="black"),
plot.title = element_text(size = 20, face="bold", hjust=0.5),
text = element_text(size=25))
#Assigning the folder and loading the package ggplot2
library(ggplot2)
#Analyzing the outliers
ggplot(data)+
aes(x = TasaFertilidad, y = IngresoPerCapita) +
geom_point() +
ggtitle("Tasa Fertilidad vs Ingreso Per Cápita (2019)") +
xlab("Promedio de niños por mujer") +
ylab("Promedio ingreso per capita, en miles de US$") +
theme_bw() +
theme(axis.title = element_text(size = 15),
axis.text = element_text(size = 10, color="black"),
plot.title = element_text(size = 20, face="bold", hjust=0.5),
text = element_text(size=25))
dataOutlier=grubbs.test(data$IngresoPerCapita, two.sided=F)
##########################################
#############Grubbs Test##################
##########################################
#install.packages("outliers")
library(outliers)
dataOutlier=grubbs.test(data$IngresoPerCapita, two.sided=F)
dataOutlier
##########################################
#############Mahalanobis##################
##########################################
library(ggplot2)
distM=mahalanobis(data[,c(4,5)],colMeans(data[,c(4,5)]),cov(data[,c(4,5)]))
? mahalanobis
#Displaying the countries
subDataCercanos=data[indexM[1:5],]
subDataLejanos=data[distM>10,]
#Sorting the distances
indexM=sort(distM, index.return=TRUE)$ix
ggplot()+
aes(x=distM)+
theme_bw()+
geom_density()+
theme(text=element_text(size=25))
#Displaying the countries
subDataCercanos=data[indexM[1:5],]
subDataLejanos=data[distM>10,]
ggplot(data)+
#aes(x=TasaFertilidad,y=IngresoPerCapita) +   theme_bw()+
aes(x=TasaFertilidad,y=IngresoPerCapita,color=distM) +   theme_bw()+
scale_color_gradient(low="blue",high="red")+
geom_point(size=1,alpha=0.8)+theme_bw()+
theme(text=element_text(size=25))+
ggtitle("Tasa Fertilidad vs Ingreso Per Cápita (2019)") + theme(plot.title = element_text(size = 20, face="bold", hjust=0.5))+
xlab("Promedio de niños por mujer") + ylab("Promedio ingreso per capita, en miles de US$") + theme(axis.title = element_text(size = 12),axis.text = element_text(size = 10, color="black"))
##########################################
#####Outlier based on KNN distance########
##########################################
#install.packages("distances")
#install.packages("dbscan")
library(distances)
library(dbscan)
#Calculating the matrix using the mahalanobis distance
indexCol=c(4,5)
tempDist=distances(data[indexCol],normalize = "mahalanobize")
tempDist=as.dist(tempDist)
#extracting the indexes with highest distance to the 4th neighboor
temp=kNNdist(tempDist,10,all=T)
temp=temp[,10]
ggplot()+
aes(x=temp)+
theme_bw()+
geom_density()+
theme(text=element_text(size=25))
#Displaying the countries
subData=data[temp>7.5,]
ggplot(data)+
#aes(x=TasaFertilidad,y=IngresoPerCapita) +   theme_bw()+
aes(x=TasaFertilidad,y=IngresoPerCapita,color=temp) +   theme_bw()+
scale_color_gradient(low="blue",high="red")+
geom_point(size=1,alpha=0.8)+theme_bw()+
ggtitle("Tasa Fertilidad vs Ingreso Per Cápita (2019)") + theme(plot.title = element_text(size = 20, face="bold", hjust=0.5))+
xlab("Promedio de niños por mujer") + ylab("Promedio ingreso per capita, en miles de US$") + theme(axis.title = element_text(size = 15),axis.text = element_text(size = 10, color="black"))
indexCol=c(4,5)
tempDist=distances(data[indexCol],normalize = "mahalanobize")
tempDist=as.dist(tempDist)
outlierScores = dbscan::lof(tempDist, k=5)
ggplot(aes(x=outlierScores)) +
geom_density() +
theme_bw() +
theme(text=element_text(size=18))
indexCol=c(4,5)
tempDist=distances(data[indexCol],normalize = "mahalanobize")
tempDist=as.dist(tempDist)
outlierScores = dbscan::lof(tempDist, k=5)
ggplot(aes(x=outlierScores)) +
geom_density() +
theme_bw() +
theme(text=element_text(size=18))
ggplot(outlierScores, aes(x = outlierScores)) +
geom_density() +
theme_bw() +
theme(text=element_text(size=18))
ggplot()+aes(x=outlierScores)+theme_bw()+geom_density()+theme(text=element_text(size=18))
#Displaying the countries
subData=data[outlierScores>3,]
ggplot(data)+
#aes(x=TasaFertilidad,y=IngresoPerCapita) +   theme_bw()+
aes(x=TasaFertilidad,y=IngresoPerCapita,color=outlierScores) +   theme_bw()+
scale_color_gradient(low="blue",high="red")+
geom_point(size=1,alpha=0.8)+theme_bw()+
ggtitle("Tasa Fertilidad vs Ingreso Per Cápita (2019)") + theme(plot.title = element_text(size = 20, face="bold", hjust=0.5))+
xlab("Promedio de niños por mujer") + ylab("Promedio ingreso per capita, en miles de US$") + theme(axis.title = element_text(size = 15),axis.text = element_text(size = 10, color="black"))+
geom_text(data=subData,label=subData$Abrev,color="blue")
ggplot(data, aes(x = TasaFertilidad, y = IngresoPerCapita, color=outlierScores)) +
geom_point(size=1,alpha=0.8) +
theme_bw() +
scale_color_gradient(low="blue", high="red")+
ggtitle("Tasa Fertilidad vs Ingreso Per Cápita (2019)") + theme(plot.title = element_text(size = 20, face="bold", hjust=0.5))+
xlab("Promedio de niños por mujer") + ylab("Promedio ingreso per capita, en miles de US$") + theme(axis.title = element_text(size = 15),axis.text = element_text(size = 10, color="black"))+
geom_text(data=subData,label=subData$Abrev,color="blue")
Para analizar casos atipicos, vamos a utilziar un dataset con las tasas de fertilidad
knitr::opts_chunk$set(echo = TRUE)
```{r cars}
library(ggplot2)
data <-read.csv("./tasaFertilidad2019vsGPD.csv")
# cargo datos
data <- read.csv("tasaFertilidad2019vsGPD.csv")
data %>% glimpse()
library(tidyverse)
```{r setup, include=FALSE, message = FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(tidyverse)
# cargo datos
data <- read.csv("tasaFertilidad2019vsGPD.csv")
data %>% glimpse()
# genero grafico
ggplot(data)+
aes(x = TasaFertilidad, y = IngresoPerCapita) +
geom_point() + # esto genera un grafico de dispersion de TasaFertilidad vs IngresoPerCapita
ggtitle("Tasa Fertilidad vs Ingreso Per Cápita (2019)") +
xlab("Promedio de niños por mujer") +
ylab("Promedio ingreso per capita, en miles de US$") +
theme_bw() +
theme(axis.title = element_text(size = 15),
axis.text = element_text(size = 10, color="black"),
plot.title = element_text(size = 20, face="bold", hjust=0.5),
text = element_text(size=25))
library(outliers)
# calculo el test de grub sobre la variable IngresoPerCapita
dataOutlier = grubbs.test(data$IngresoPerCapita, two.sided=F)
dataOutlier
# calculo el test de grub sobre la variable TasaFertilidad
dataOutlier = grubbs.test(data$TasaFertilidad, two.sided=F)
dataOutlier
predict(dataOutlier)
dataOutlier$data.name
dataOutlier$statistic
? grubbs.test
# calculo el test de grub sobre la variable TasaFertilidad
dataOutlier2 = grubbs.test(data$TasaFertilidad, two.sided=F, type = 20)
# calculo el test de grub sobre la variable TasaFertilidad
dataOutlier2 = grubbs.test(data$TasaFertilidad, two.sided=F, type = 20)
# calculo el test de grub sobre la variable TasaFertilidad
dataOutlier2 = grubbs.test(data$TasaFertilidad, type = 20)
# calculo el test de grub sobre la variable TasaFertilidad
dataOutlier2 = grubbs.test(data$TasaFertilidad, two.sided=F, type = 2)
# calculo el test de grub sobre la variable TasaFertilidad
dataOutlier2 = grubbs.test(data$TasaFertilidad, two.sided=F)
distM = mahalanobis(data[,c(4,5)],colMeans(data[,c(4,5)]),cov(data[,c(4,5)]))
sort(distM, index.return=TRUE)$ix
ggplot(data)+
aes(x=TasaFertilidad,y=IngresoPerCapita,color=distM) +
scale_color_gradient(low="blue",high="red")+
geom_point(size=1,alpha=0.8)+theme_bw()+
ggtitle("Tasa Fertilidad vs Ingreso Per Cápita (2019)") +
xlab("Promedio de niños por mujer") +
ylab("Promedio ingreso per capita, en miles de US$") +
theme_bw() +
theme(axis.title = element_text(size = 12),
axis.text = element_text(size = 10, color="black"),
text=element_text(size=25),
plot.title = element_text(size = 20, face="bold", hjust=0.5))
ggplot()+
aes(x=distM)+
theme_bw()+
geom_density()+
theme(text=element_text(size=25))
ggplot(data, aes(x=TasaFertilidad, y=IngresoPerCapita,color=distM)) +
scale_color_gradient(low="blue",high="red")+
geom_point(size=1,alpha=0.8)+theme_bw()+
ggtitle("Tasa Fertilidad vs Ingreso Per Cápita (2019)") +
xlab("Promedio de niños por mujer") +
ylab("Promedio ingreso per capita, en miles de US$") +
theme_bw() +
theme(axis.title = element_text(size = 12),
axis.text = element_text(size = 10, color="black"),
text=element_text(size=25),
plot.title = element_text(size = 20, face="bold", hjust=0.5))
# Visualizo la distribucion de las distancias
ggplot(distM %>% as.tibble())+
aes(x=distM)+
theme_bw()+
geom_density()+
theme(text=element_text(size=25))
# Visualizo la distribucion de las distancias
ggplot(distM %>% as_tibble())+
aes(x=distM)+
theme_bw()+
geom_density()+
theme(text=element_text(size=25))
# Visualizo la distribucion de las distancias
ggplot(distM %>% as_tibble(), aes(x=distM))+
theme_bw()+
geom_density()+
theme(text=element_text(size=25))
# Visualizo la distribucion de las distancias
ggplot(distM %>% as_tibble())+
theme_bw()+
geom_density()+
theme(text=element_text(size=25))
# Visualizo la distribucion de las distancias
ggplot(distM %>% as_tibble(), aes(x=distM)) +
geom_density() +
theme_bw() +
theme(text=element_text(size=25))
ggplot(data, aes(x=TasaFertilidad, y=IngresoPerCapita,color=distM)) +
scale_color_gradient(low="blue",high="red") +
geom_point(size=1, alpha=0.8) +
ggtitle("Tasa Fertilidad vs Ingreso Per Cápita (2019)") +
xlab("Promedio de niños por mujer") +
ylab("Promedio ingreso per capita, en miles de US$") +
theme_bw() +
theme(axis.title = element_text(size = 12),
axis.text = element_text(size = 10, color="black"),
text=element_text(size=25),
plot.title = element_text(size = 20, face="bold", hjust=0.5))
# invoco librerias
library(distances)
library(dbscan)
#Calculating the matrix using the mahalanobis distance
indexCol=
tempDist=distances(data[,c(4,5)],normalize = "mahalanobize")
#Calculo distancias de mahalanobis, utilizando otro metodo disponible en la libreria distances
tempDist <- distances(data[,c(4,5)],normalize = "mahalanobize")
tempDist <- as.dist(tempDist)
#Calculo distancias de mahalanobis, utilizando otro metodo disponible en la libreria distances
tempDist <- distances(data[,c(4,5)],normalize = "mahalanobize") %>% as.dist()
#extracting the indexes with highest distance to the 4th neighboor
temp=kNNdist(tempDist,4,all=T)
temp=temp[,4]
#extracting the indexes with highest distance to the 4th neighboor
temp=kNNdist(tempDist,4,all=T)
temp=temp[,4]
ggplot()+
aes(x=temp)+
theme_bw()+
geom_density()+
theme(text=element_text(size=25))
ggplot(data, aes(x=TasaFertilidad,y=IngresoPerCapita,color=temp)) +
geom_point(size=1,alpha=0.8)+theme_bw()+
scale_color_gradient(low="blue",high="red")+
ggtitle("Tasa Fertilidad vs Ingreso Per Cápita (2019)") +
theme_bw() +
theme(plot.title = element_text(size = 20, face="bold", hjust=0.5),
axis.title = element_text(size = 15),
axis.text = element_text(size = 10, color="black")) +
xlab("Promedio de niños por mujer") +
ylab("Promedio ingreso per capita, en miles de US$")
ggplot(temp %>% as_tibble(), aes(x=temp)) +
geom_density() +
theme_bw() +
theme(text=element_text(size=25))
# visualizo la densidad de estas distancias
ggplot(temp %>% as_tibble(), aes(x=temp)) +
geom_density() +
theme_bw() +
theme(text=element_text(size=25))
#preservo las 4 distancias menores
temp <- kNNdist(tempDist, 4, all=T)
temp[1,]
# visualizo el diagrama de dispersion, coloreado segun distancia maxima de knn
ggplot(data, aes(x=TasaFertilidad,y=IngresoPerCapita,color=temp)) +
geom_point(size=1,alpha=0.8)+theme_bw()+
scale_color_gradient(low="blue",high="red")+
ggtitle("Tasa Fertilidad vs Ingreso Per Cápita (2019)") +
theme_bw() +
theme(plot.title = element_text(size = 20, face="bold", hjust=0.5),
axis.title = element_text(size = 15),
axis.text = element_text(size = 10, color="black")) +
xlab("Promedio de niños por mujer") +
ylab("Promedio ingreso per capita, en miles de US$")
temp <- temp[,4] # preservo la maxima de las 4 distancias cercanas
# visualizo la densidad de estas distancias maximas
ggplot(temp %>% as_tibble(), aes(x=temp)) +
geom_density() +
theme_bw() +
theme(text=element_text(size=25))
# visualizo el diagrama de dispersion, coloreado segun distancia maxima de knn
ggplot(data, aes(x=TasaFertilidad,y=IngresoPerCapita,color=temp)) +
geom_point(size=1,alpha=0.8)+theme_bw()+
scale_color_gradient(low="blue",high="red")+
ggtitle("Tasa Fertilidad vs Ingreso Per Cápita (2019)") +
theme_bw() +
theme(plot.title = element_text(size = 20, face="bold", hjust=0.5),
axis.title = element_text(size = 15),
axis.text = element_text(size = 10, color="black")) +
xlab("Promedio de niños por mujer") +
ylab("Promedio ingreso per capita, en miles de US$")
# genero grafico
ggplot(data, aes(x = TasaFertilidad, y = IngresoPerCapita)) +
geom_point() + # esto genera un grafico de dispersion de TasaFertilidad vs IngresoPerCapita
ggtitle("Tasa Fertilidad vs Ingreso Per Cápita (2019)") +
xlab("Promedio de niños por mujer") +
ylab("Promedio ingreso per capita, en miles de US$") +
theme_bw() +
theme(axis.title = element_text(size = 15),
axis.text = element_text(size = 10, color="black"),
plot.title = element_text(size = 20, face="bold", hjust=0.5),
text = element_text(size=25))
outlierScores = dbscan::lof(tempDist, k=5)
## calculo el lof a partir de distancias mahalanobis calculadas en paso anterior (tempDist)
outlierScores = dbscan::lof(tempDist, k=5)
ggplot(outlierScores %>% as_tibble(), aes(x= outlierScores)) +
theme_bw() +
geom_density() +
theme(text=element_text(size=18))
ggplot(outlierScores %>% as_tibble(), aes(x= outlierScores)) +
geom_density() +
theme_bw() +
theme(text=element_text(size=18))
# genero subconjunto de datos con puntajes de outliers altos
subData=data[outlierScores>3,]
ggplot(data, aes(x = TasaFertilidad, y = IngresoPerCapita, color = outlierScores)) +
geom_point(size=1,alpha=0.8) +
geom_text(data=subData,label=subData$Abrev,color="blue") +
scale_color_gradient(low="blue", high="red")+
ggtitle("Tasa Fertilidad vs Ingreso Per Cápita (2019)") +
xlab("Promedio de niños por mujer") +
ylab("Promedio ingreso per capita, en miles de US$") +
theme_bw() +
theme(axis.title = element_text(size = 15),
axis.text = element_text(size = 10, color="black"),
plot.title = element_text(size = 20, face="bold", hjust=0.5))
# visualizo dispersion, coloreada segun LOF
ggplot(data, aes(x = TasaFertilidad, y = IngresoPerCapita, color = outlierScores)) +
geom_point(size=1,alpha=0.8) +
geom_text(data=subData, label=subData$Abrev, color="blue") +  # visualizo los textos (Abrev) de valores atipicos
scale_color_gradient(low="blue", high="red")+
ggtitle("Tasa Fertilidad vs Ingreso Per Cápita (2019)") +
xlab("Promedio de niños por mujer") +
ylab("Promedio ingreso per capita, en miles de US$") +
theme_bw() +
theme(axis.title = element_text(size = 15),
axis.text = element_text(size = 10, color="black"),
plot.title = element_text(size = 20, face="bold", hjust=0.5))
